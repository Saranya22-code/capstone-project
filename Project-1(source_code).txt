
Server code:(server.c)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <sys/shm.h>
#include <semaphore.h>
#include <time.h>
#define PORT 9999 // Port number for server to listen on
#define SHM_KEY 1234 // Key for shared memory
#define SHM_SIZE 1024 // Size of shared memory
// Shared resource
char *shared_data;
sem_t *semaphore;
sem_t client_semaphore;
int shared_data_updated = 0; // Flag to indicate shared memory update
int client_count = 0; // Count of connected clients
// Thread function for logging shared memory updates to a file
void *log_shared_memory(void *arg) {
 FILE *log_file = fopen("shared_memory_log.txt", "a");
 if (!log_file) {
 perror("fopen");
 return NULL;
 }
 while (1) {
 // Check if shared memory has been updated
 sem_wait(semaphore);
 if (shared_data_updated) {
 char data[SHM_SIZE];
 strncpy(data, shared_data, SHM_SIZE);
 shared_data_updated = 0;
 sem_post(semaphore);
 // Get current time for logging
 time_t now = time(NULL);
 struct tm *t = localtime(&now);
 // Log the data with timestamp
 fprintf(log_file, "[%04d-%02d-%02d %02d:%02d:%02d] %s\n",
 t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,
 t->tm_hour, t->tm_min, t->tm_sec, data);
 fflush(log_file);
 } else {
 sem_post(semaphore);
 sleep(1); // Sleep for a while before checking again
 }
 }
 fclose(log_file);
 return NULL;
}
// Thread function for handling individual clients
void *handle_client(void *arg) {
 int client_socket = *(int *)arg;
 free(arg);
 // Update client count safely
 sem_wait(&client_semaphore);
 int client_number = ++client_count;
 sem_post(&client_semaphore);
 char buffer[256];
 char response[256];
 while (1) {
 memset(buffer, 0, 256);
 int n = read(client_socket, buffer, 255);
 if (n <= 0) {
 break;
 }
 // Update shared memory with client message
 sem_wait(semaphore);
 snprintf(shared_data, SHM_SIZE, "Client %d: %s", client_number, buffer);
 shared_data_updated = 1;
 sem_post(semaphore);
 printf("Received from Client %d: %s", client_number, buffer);
 // Server prompts for a response
 printf("Enter message to Client %d: ", client_number);
 memset(response, 0, 256);
 fgets(response, 255, stdin);
 // Update shared memory with server response
 sem_wait(semaphore);
 snprintf(shared_data, SHM_SIZE, "Server to Client %d: %s", client_number, 
response);
 shared_data_updated = 1;
 sem_post(semaphore);
 n = write(client_socket, response, strlen(response));
 if (n < 0) {
 perror("ERROR writing to socket");
 }
 }
 printf("Client %d is disconnected\n", client_number);
 close(client_socket);
 return NULL;
}
int main() {
int server_socket, client_socket, *new_sock;
 struct sockaddr_in server_addr, client_addr;
 socklen_t client_len;
 pthread_t thread_id, log_thread_id;
 // Initialize shared memory
 int shm_id = shmget(SHM_KEY, SHM_SIZE, IPC_CREAT | 0666);
 if (shm_id == -1) {
 perror("shmget");
 exit(EXIT_FAILURE);
 }
 printf("shmid: %d\n", shm_id);
 shared_data = (char *)shmat(shm_id, NULL, 0);
 if (shared_data == (char *)-1) {
 perror("shmat");
 exit(EXIT_FAILURE);
 }
 // Initialize semaphores
 semaphore = sem_open("/my_semaphore", O_CREAT, 0666, 1);
 if (semaphore == SEM_FAILED) {
 perror("sem_open");
 exit(EXIT_FAILURE);
 }
 sem_init(&client_semaphore, 0, 1);
 // Create socket
 server_socket = socket(AF_INET, SOCK_STREAM, 0);
 if (server_socket < 0) {
 perror("ERROR opening socket");
 exit(EXIT_FAILURE);
 }
 // Prepare server address structure
 memset((char *)&server_addr, 0, sizeof(server_addr));
server_addr.sin_family = AF_INET;
 server_addr.sin_addr.s_addr = INADDR_ANY;
 server_addr.sin_port = htons(PORT);
 // Bind socket
 if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
 perror("ERROR on binding");
 exit(EXIT_FAILURE);
}
 // Listen for incoming connections
 listen(server_socket, 5);
 printf("Server listening on port %d\n", PORT);
 // Start logging thread
 if (pthread_create(&log_thread_id, NULL, log_shared_memory, NULL) < 0) {
 perror("could not create logging thread");
 exit(EXIT_FAILURE);
 }
 // Accept incoming connections
 while (1) {
 client_len = sizeof(client_addr);
 client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_len);
 if (client_socket < 0) {
 perror("ERROR on accept");
 exit(EXIT_FAILURE);
 }
 printf("Client %d is connected\n", client_count + 1);
 new_sock = malloc(sizeof(int));
 *new_sock = client_socket;
 if (pthread_create(&thread_id, NULL, handle_client, (void *)new_sock) < 0) {
 perror("could not create thread");
 exit(EXIT_FAILURE);
 }
 }
 close(server_socket);
 shmctl(shm_id, IPC_RMID, NULL);
 sem_close(semaphore);
 sem_unlink("/my_semaphore");
 sem_destroy(&client_semaphore);
 return 0;
}


Client Code:(client.c)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <sys/shm.h>
#include <arpa/inet.h>
#include <semaphore.h>
#define PORT 9999 // Port number for server connection
#define SHM_KEY 1234 // Key for shared memory
#define SHM_SIZE 1024 // Size of shared memory
int main() {
 int sockfd, n;
 struct sockaddr_in server_addr;
 char buffer[256];
 // Initialize shared memory
 int shm_id = shmget(SHM_KEY, SHM_SIZE, 0666);
 if (shm_id == -1) {
 perror("shmget");
 exit(EXIT_FAILURE);
 }
 char *shared_data = (char *)shmat(shm_id, NULL, 0);
 if (shared_data == (char *)-1) {
 perror("shmat");
 exit(EXIT_FAILURE);
 }
 // Initialize semaphore
sem_t *semaphore = sem_open("/my_semaphore", 0);
 if (semaphore == SEM_FAILED) {
 perror("sem_open");
 exit(EXIT_FAILURE);
 }
 // Create socket
 sockfd = socket(AF_INET, SOCK_STREAM, 0);
 if (sockfd < 0) {
 perror("ERROR opening socket");
 exit(EXIT_FAILURE);
 }
 // Prepare server address structure
 memset((char *)&server_addr, 0, sizeof(server_addr));
 server_addr.sin_family = AF_INET;
 server_addr.sin_port = htons(PORT);
 if (inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr) <= 0) {
 perror("ERROR invalid address");
 exit(EXIT_FAILURE);
 }
 // Connect to server
 if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
 perror("ERROR connecting");
 exit(EXIT_FAILURE);
 }
 while (1) {
 printf("Enter message to server: ");
 memset(buffer, 0, 256);
 fgets(buffer, 255, stdin);
 if (strncmp(buffer, "exit", 4) == 0) {
 break;
 }
 n = write(sockfd, buffer, strlen(buffer));
 if (n < 0) {
 perror("ERROR writing to socket");
 }
 memset(buffer, 0, 256);
 n = read(sockfd, buffer, 255);
 if (n < 0) {
 perror("ERROR reading from socket");
 }
 printf("Received from server: %s", buffer);
 // Print shared memory contents after receiving the response
 sem_wait(semaphore);
 printf("Shared memory contains: %s\n", shared_data);
 sem_post(semaphore);
 }
 close(sockfd);
 return 0;
}